<html lang="en">
<head>
<title>PRNG User Manual</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name=description content="PRNG User Manual">
<meta name=generator content="makeinfo 4.2">
<link href="http://www.gnu.org/software/texinfo/" rel=generator-home>
</head>
<body>
<p>
Node:<a name="Description">Description</a>,
Next:<a rel=next accesskey=n href="Functions.html#Functions">Functions</a>,
Up:<a rel=up accesskey=u href="Usage.html#Usage">Usage</a>
<hr><br>

<h3>Interface Description</h3>

<p>The interface has changed dramatically in version 2.0. As more and
more generator types were added to this package, a new generic interface
was needed. While still plain Ansi C, the architecture is now
object-oriented.

<p>All generators are identified by a textual description. This description
is either of the form <code>"type(parameter1,parameter2, ...)"</code> or is a
shortcut name for a common PRNG as defined in <code>src/prng_def.h</code>.

<p>Calling <code>prng_new</code> with such a description as the only argument will
allocate a new generator object, initialize it, and return its handle
(<code>struct prng *</code>).

<p>All further calls need this handle as the first argument. They are
best explained by example:

<br><pre>#include &lt;prng.h&gt;   /* make sure that the compiler can find this file. */

main()
{
   struct prng *g;
   prng_num seed, n, M;
   double next, *array;
   int count;

   g = prng_new("eicg(2147483647,111,1,0)");

   if (g == NULL) /* always check whether prng_new has been successful */
   {
      fprintf(stderr,"Initialisation of generator failed.\n");
      exit (-1);
   }

   printf("Short name: %s\n",prng_short_name(g));
                                  /* definition as in call to prng_new */
   printf("Expanded name: %s\n",prng_long_name(g));
                                  /* Shortcuts expanded                */

   next = prng_get_next(g);       /* get next number 0 &lt;= next &lt; 1     */
   prng_get_array(g,array,count); /* fill array with count numbers     */
   prng_reset(g);                 /* reset the generator */
   prng_free(g);                  /* deallocate the generator object   */

}

</pre>

<p>These functions work with all generators. For certain generators,
the following functions are available, too:

<br><pre>
if (prng_is_congruential(g))
{
   n = prng_get_next_int(g);       /* return next *unscaled* number    */
   M = prng_get_modulus(g);        /* return the modulus of the prng   */
}

if (prng_can_seed(g))
   prng_seed(g,seed);              /* reseed the generator             */

if (prng_can_fast_sub(g))
   puts(prng_get_sub_def(g,20,0)); /* Get subsequence definition       */

if (prng_can_fast_con(g))
   puts(prng_get_con_def(g,20,1)); /* Get block definition             */

</pre>

<p><strong>NOTE:</strong><br>
<code>prng_new</code> performs only a rudimentary check on the parameters. 
The user is responsible for enforcing all restrictions
on the parameters, such as checking that the modulus of an [E]ICG is
prime, or that LCG and ICG are maximum period generators.

<p>Most of these functions are implemented as macros, so be
careful with autoincrements (<code>++</code>) in parameters.

</body></html>

